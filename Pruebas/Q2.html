<html><head><title>Consulta: segmentos de memoria compartida</title></head><body><h3>#1     52.381831353313245     ../ConsulterRIT/man.es/man8/ipcs.8</h3><h4>Descripcion:</h4><p>ipcs proporciona información recursos del ipc cuales proceso llama tiene acceso opción -i permite se especifique id recurso sólo se mostrará información id se recursos se pueden especificar tal como sigue -m segmentos memoria compartida -q colas mensajes -s matrices semáforos -a todos esta es opción defecto formato salida se puede especificar sigu­ientes maneras -t tiempo -p pid identificador proceso -c creador -l límites -u sumario véase también ipcrm(8) autor krishna balasubramanian balasub@cis.ohio-state.edu linux 0.99 9 octubre 1993 ipcs(8) balasub@cis ohio-state edu </p><h3>#2     41.534100185713335     ../ConsulterRIT/man.es/man2/shmctl.2</h3><h4>Descripcion:</h4><p>shmctl() permite al usuario recibir información segmento memoria compartida establecer dueño grupo permisos del segmento así como informa­ ción segmento identificado como shmid se devuelve estructura shmid_ds struct shmid_ds { struct ipc_perm shm_perm /* permisos operación */ int shm_segsz /* tamaño del segmento bytes */ time_t shm_atime /* tiempo última unión */ time_t shm_dtime /* tiempo última separación */ time_t shm_ctime /* tiempo del último cambio */ unsigned short shm_cpid /* pid del creador */ unsigned short shm_lpid /* pid del último operador */ short shm_nattch /* nº uniones actuales */ /* siguientes son privados */ unsigned short shm_npages /* tamaño del segmento páginas */ unsigned long *shm_pages struct shm_desc *attaches /* descriptores uniones */ } campos del miembro shm_perm pueden ser struct ipc_perm { key_t key ushort uid /* euid egid del dueño */ ushort gid ushort cuid /* euid egid del creador */ ushort cgid ushort mode /* 9 bits más bajos modos acceso */ ushort seq /* número secuencia */ } están disponibles siguientes cmds ipc_stat se usa copiar información segmento memoria compartida memoria intermedia usuario debe tener permiso lectura del segmento memoria ipc_set se usa aplicar cambios usuario ha efectuado miembros uid gid mode del campo </p><h3>#3     38.63102191896043     ../ConsulterRIT/man.es/man1/ld.1</h3><h4>Descripcion:</h4><p>ld combina número ficheros objeto archivos reubi­ca sus datos enlaza referencias menudo último paso proceso construcción nuevo pro­grama compilado su ejecución es llamada ld acepta ficheros lenguaje órdenes enlazador proporcionar control explícito total pro­ceso esta página del manual no describe lenguaje órdenes consulte entrada menú `ld' `info' manual ld enlazador gnu todos detalles lenguaje órdenes otros aspectos del enlazador esta versión ld emplea bibliotecas bfd propósito general operar ficheros esto permite ld leer combinar escribir ficheros objetos varios formatos diferentes ejemplo coff se pueden enlazar juntos formatos diferentes producir cualquier clase disponible fichero puede emplear `ob­jdump -i' obtener lista formatos soporta­dos varias arquitecturas consulte aparte su flexibilidad enlazador gnu es más útil otros enlazadores tarea proporcionar informa­ción muchos enlazadores abandonan eje­cución inmediatamente cuando encuentran error mientras sea posible ld continúa ejecutándose permitiéndole iden­tificar otros errores o algunos casos obtener fichero salida pesar del enlazador gnu ld está diseñado cubrir amplio rango situaciones ser tan compatible como sea posible otros como resultado esto tiene muchas opciones controlar su comportamiento través línea órdenes mediante variables opciones enorme cantidad opciones línea órdenes puede parecer intimidatoria práctica real pocas ellas se emplean cualquier contexto ejemplo uso frecuente ld es enlazar ficheros objetos normales unix </p><h3>#4     37.89045665515481     ../ConsulterRIT/man.es/man1/free.1</h3><h4>Descripcion:</h4><p>free muestra cantidad total memoria fisica intercambio presente sistema asi como memoria compartida buffers usados nucleo opciones modificador -b muestra cantidad memoria bytes modificador -k puesto defecto muestra kilo­bytes; modificador -m muestra modificador -t muestra linea modificador -o desactiva mostrar linea ajuste q no se especifique free quita/anade memoria buffer desde/hacia informe memoria usada/libre ¡respectivamente! modificador -s activa refresco informacion cada retardo es posible especificar cualquier numero coma flotante retardo usleep(3) es usado precision milisegundos tiempos modificador -v muestra informacion referente ficheros /proc/meminfo-informacion acerca memoria véase también ps(1) top(1) autores escrito brian enviar avisos fallos <procps-bugs@redhat.com> cohesive systems 20 marzo 1993 free(1) <procps-bugs@redhat com> </p><h3>#5     32.73430002843049     ../ConsulterRIT/man.es/man7/bootparam.7</h3><h4>Descripcion:</h4><p>núcleo linux acepta ciertas `opciones línea orden' `parámetros arranque' cuando se gen­ eral esto sirve suministrar al núcleo información parámetros del equipo núcleo es incapaz determinar sí mismo evitar cambiar val­ores núcleo cuando es bios quien arranca directamente núcleo por ejemplo disquete donde copió núcleo mediante `cp zimage /dev/fd0' no tiene oportunidad especificar ningún así aprovechar esta posibilidad debe emplear algún programa capaz pasar parámetros como lilo algunos pocos parámetros puede también modificar propia imagen del núcleo empleando rdev vea rdev(8) más programa lilo linux loader cargador linux escrito werner almesberger es más empleado tiene capacidad arrancar varios núcleos guarda información configuración fichero texto (vea lilo(8) lilo.conf(5).) lilo puede arrancar también dos os/2 linux freebsd unixware es bastante otro cargador linux empleado comúnmente es `load­lin' es programa dos capacidad lanzar núcleo linux línea órdenes del dos con argumentos arranque suponiendo se dispone ciertos esto está bien gente quiera lanzar linux también es muy útil si posee cierto hardware con­fía controlador suministrado dos poner equipo estado ejemplo muy común es tarjetas sonido `compatibles sound­blaster' necesitan controlador dos hacer no se sabe qué pocos misteriosos registros fin poner tarjeta modo compatible arrancar dos controlador marras cargar luego linux indicador del dos mediante </p><h3>#6     24.3899872918242     ../ConsulterRIT/man.es/man2/shmget.2</h3><h4>Descripcion:</h4><p>shmget() devuelve identificativo del segmento memo­ria compartida asociado al valor del argumento se crea nuevo segmento memoria compartida tamaño igual al múltiplo page_size más aproximado por exceso size si key tiene valor ipc_private key no es ipc_private no hay ningún segmento memoria compartida asociado key ipc_creat está declarado shmflg es decir shmflg&ipc_creat es distinto presen­ cia shmflg está compuesta de ipc_creat crear nuevo si este indi­cador no se usa shmget() encontrará seg­mento asociado key comprobará usuario tenga permiso recibir shmid asociado segmento se asegurará segmento no esté marcado ipc_excl usado ipc_creat asegurar fallo si segmento mode_flags 9 bits más bajos especifican permisos otorgados al dueño grupo resto del actualmente sis­tema no usa permisos si se crea nuevo segmento permisos acceso shmflg son copiados al miembro shm_perm estructura shmid_ds define estructura shmid_ds struct shmid_ds { struct ipc_perm shm_perm /* permisos operación */ int shm_segsz /* tamaño del segmento bytes */ time_t shm_atime /* tiempo última unión */ time_t shm_dtime /* tiempo última separación */ time_t shm_ctime /* tiempo del último cambio */ unsigned short shm_cpid /* pid del creador */ unsigned short shm_lpid /* pid del último operador */ short shm_nattch /* nº uniones actuales */ } struct ipc_perm { key_t </p><h3>#7     24.204866836063086     ../ConsulterRIT/man.es/man2/shmat.2</h3><h4>Descripcion:</h4><p>función shmat pega segmento memoria compartida identificada shmid al segmento datos del proceso llama dirección del pegado se especifica shmaddr según criterios sigu­ientes: si shmaddr es 0 sistema intenta encontrar región no asociada rango 1 1 5 gb comen­zando valor superior bajando si shmaddr no es 0 shm_rnd está activado shm­flg pegado ocurre dirección igual al redondeo abajo shmaddr múltiplo otro modo shmaddr debe ser direc­ción alineada página cual ocurra si shm_rdonly está activado shmflg segmento se pega lectura proceso debe tener permiso lectura otro modo segmento se pega lec­tura escritura debe tener permisos lectura escritura no existe noción segmentos memoria compartida escritura valor brk del proceso llama función no se altera segmento se despegará automáti­camente cuendo proceso se mismo segmento puede ser pegaado como lectura lectura-escritura más vez espacio direcciones del llamada exitosa shmat sistema actualiza miembros estructura shmid_ds asociada al segmento memoria compartida como sigue shm_atime toma valor hora shm_lpid toma valor del pid del proceso shm_nattch se incrementa observe pegado tiene éxito también si segmento memoria compartida se marca como ser función shmdt despega del segmento datos del proceso llama segmento memoria compartida localizado dirección especificada segmento memoria compartida despegado debe ser pegados actualmente al espacio direcciones </p><h3>#8     24.204866836063086     ../ConsulterRIT/man.es/man2/shmdt.2</h3><h4>Descripcion:</h4><p>función shmat pega segmento memoria compartida identificada shmid al segmento datos del proceso llama dirección del pegado se especifica shmaddr según criterios sigu­ientes: si shmaddr es 0 sistema intenta encontrar región no asociada rango 1 1 5 gb comen­zando valor superior bajando si shmaddr no es 0 shm_rnd está activado shm­flg pegado ocurre dirección igual al redondeo abajo shmaddr múltiplo otro modo shmaddr debe ser direc­ción alineada página cual ocurra si shm_rdonly está activado shmflg segmento se pega lectura proceso debe tener permiso lectura otro modo segmento se pega lec­tura escritura debe tener permisos lectura escritura no existe noción segmentos memoria compartida escritura valor brk del proceso llama función no se altera segmento se despegará automáti­camente cuendo proceso se mismo segmento puede ser pegaado como lectura lectura-escritura más vez espacio direcciones del llamada exitosa shmat sistema actualiza miembros estructura shmid_ds asociada al segmento memoria compartida como sigue shm_atime toma valor hora shm_lpid toma valor del pid del proceso shm_nattch se incrementa observe pegado tiene éxito también si segmento memoria compartida se marca como ser función shmdt despega del segmento datos del proceso llama segmento memoria compartida localizado dirección especificada segmento memoria compartida despegado debe ser pegados actualmente al espacio direcciones </p><h3>#9     24.204866836063086     ../ConsulterRIT/man.es/man2/shmop.2</h3><h4>Descripcion:</h4><p>función shmat pega segmento memoria compartida identificada shmid al segmento datos del proceso llama dirección del pegado se especifica shmaddr según criterios sigu­ientes: si shmaddr es 0 sistema intenta encontrar región no asociada rango 1 1 5 gb comen­zando valor superior bajando si shmaddr no es 0 shm_rnd está activado shm­flg pegado ocurre dirección igual al redondeo abajo shmaddr múltiplo otro modo shmaddr debe ser direc­ción alineada página cual ocurra si shm_rdonly está activado shmflg segmento se pega lectura proceso debe tener permiso lectura otro modo segmento se pega lec­tura escritura debe tener permisos lectura escritura no existe noción segmentos memoria compartida escritura valor brk del proceso llama función no se altera segmento se despegará automáti­camente cuendo proceso se mismo segmento puede ser pegaado como lectura lectura-escritura más vez espacio direcciones del llamada exitosa shmat sistema actualiza miembros estructura shmid_ds asociada al segmento memoria compartida como sigue shm_atime toma valor hora shm_lpid toma valor del pid del proceso shm_nattch se incrementa observe pegado tiene éxito también si segmento memoria compartida se marca como ser función shmdt despega del segmento datos del proceso llama segmento memoria compartida localizado dirección especificada segmento memoria compartida despegado debe ser pegados actualmente al espacio direcciones </p><h3>#10     20.774674022567893     ../ConsulterRIT/man.es/man2/getrlimit.2</h3><h4>Descripcion:</h4><p>getrlimit setrlimit devuelve / establece límite recursos resource debería ser siguientes rlimit_cpu /* tiempo cpu segundos */ rlimit_fsize /* tamaño máximo fichero */ rlimit_data /* tamaño máximo datos */ rlimit_stack /* tamaño máximo pila */ rlimit_core /* tamaño máximo del fichero del núcleo */ rlimit_rss /* tamaño máximo parte residente fija */ rlimit_nproc /* núero máximo procesos */ rlimit_nofile /* número máximo ficheros abiertos */ rlimit_memlock /* máximo espacio direcciones fijado memoria*/ recurso puede definirse como ilimitado si se establece límite rlimit_ofile es nombre bsd estructura rlimit está definida como sigue struct rlimit { int rlim_cur int rlim_max } getrusage devuelve utilización actual recursos who cualquiera siguientes bien rusage_self oo struct rusage { struct timeval ru_utime /* tiempo usuario utilizado */ struct timeval ru_stime /* tiempo sistema utilizado */ long ru_maxrss /* tamaño máximo parte establecida como residente */ long ru_ixrss /* tamaño total memoria compartida */ long ru_idrss /* tamaño total memoria no compartida */ long ru_isrss /* tamaño pila no compartido */ long ru_minflt /* peticiones página */ long ru_majflt /* fallos página */ long ru_nswap /* intercambios */ long ru_inblock /* operaciones entrada bloques */ long ru_oublock /* operaciones salida bloques */ long ru_msgsnd /* mensajes enviados </p><h3>#11     20.774674022567893     ../ConsulterRIT/man.es/man2/getrusage.2</h3><h4>Descripcion:</h4><p>getrlimit setrlimit devuelve / establece límite recursos resource debería ser siguientes rlimit_cpu /* tiempo cpu segundos */ rlimit_fsize /* tamaño máximo fichero */ rlimit_data /* tamaño máximo datos */ rlimit_stack /* tamaño máximo pila */ rlimit_core /* tamaño máximo del fichero del núcleo */ rlimit_rss /* tamaño máximo parte residente fija */ rlimit_nproc /* núero máximo procesos */ rlimit_nofile /* número máximo ficheros abiertos */ rlimit_memlock /* máximo espacio direcciones fijado memoria*/ recurso puede definirse como ilimitado si se establece límite rlimit_ofile es nombre bsd estructura rlimit está definida como sigue struct rlimit { int rlim_cur int rlim_max } getrusage devuelve utilización actual recursos who cualquiera siguientes bien rusage_self oo struct rusage { struct timeval ru_utime /* tiempo usuario utilizado */ struct timeval ru_stime /* tiempo sistema utilizado */ long ru_maxrss /* tamaño máximo parte establecida como residente */ long ru_ixrss /* tamaño total memoria compartida */ long ru_idrss /* tamaño total memoria no compartida */ long ru_isrss /* tamaño pila no compartido */ long ru_minflt /* peticiones página */ long ru_majflt /* fallos página */ long ru_nswap /* intercambios */ long ru_inblock /* operaciones entrada bloques */ long ru_oublock /* operaciones salida bloques */ long ru_msgsnd /* mensajes enviados </p><h3>#12     20.774674022567893     ../ConsulterRIT/man.es/man2/setrlimit.2</h3><h4>Descripcion:</h4><p>getrlimit setrlimit devuelve / establece límite recursos resource debería ser siguientes rlimit_cpu /* tiempo cpu segundos */ rlimit_fsize /* tamaño máximo fichero */ rlimit_data /* tamaño máximo datos */ rlimit_stack /* tamaño máximo pila */ rlimit_core /* tamaño máximo del fichero del núcleo */ rlimit_rss /* tamaño máximo parte residente fija */ rlimit_nproc /* núero máximo procesos */ rlimit_nofile /* número máximo ficheros abiertos */ rlimit_memlock /* máximo espacio direcciones fijado memoria*/ recurso puede definirse como ilimitado si se establece límite rlimit_ofile es nombre bsd estructura rlimit está definida como sigue struct rlimit { int rlim_cur int rlim_max } getrusage devuelve utilización actual recursos who cualquiera siguientes bien rusage_self oo struct rusage { struct timeval ru_utime /* tiempo usuario utilizado */ struct timeval ru_stime /* tiempo sistema utilizado */ long ru_maxrss /* tamaño máximo parte establecida como residente */ long ru_ixrss /* tamaño total memoria compartida */ long ru_idrss /* tamaño total memoria no compartida */ long ru_isrss /* tamaño pila no compartido */ long ru_minflt /* peticiones página */ long ru_majflt /* fallos página */ long ru_nswap /* intercambios */ long ru_inblock /* operaciones entrada bloques */ long ru_oublock /* operaciones salida bloques */ long ru_msgsnd /* mensajes enviados </p><h3>#13     19.76930157532651     ../ConsulterRIT/man.es/man2/intro.2</h3><h4>Descripcion:</h4><p>este capítulo describe llamadas al sistema syscalls(2) encontrará lista 164 llamadas al sistema presentes linux 2.0 llamadas directas mayoría casos no es necesario invocar llamada al sistema directamente hay veces biblioteca c estándar carece función sinopsis #include <linux/unistd.h> macro tipo _syscall configuración importante conocer llamada al sistema es su es necesario saber cuántos argumentos usa sus tipos tipo retornado hay seis macros facilitan llamada real al tienen sigu­iente forma _syscallx(tipo nombre tipo1 arg1 tipo2 arg2 donde x es 0-5 número argumentos usado llamada del sistema tipo es tipo devuelto llamada al sistema nombre es nombre llamada al sistema tipon es tipo del argumento nº n argn es nombre del argumento nº n estas macros crean función llamada nombre argumentos vez incluida _syscall() fichero fuente se invoca llamada al sistema ejemplo #include <stdio.h> #include <linux/unistd.h> /* macros _syscallx */ #include <linux/kernel.h> /* estructura sysinfo */ _syscall1(int sysinfo struct sysinfo * info /* nota si copia directamente fuente nroff recuerde borrar barras invertidas extra sentencias printf */ int main(void) { struct sysinfo s_info int error error = sysinfo(&s_info) printf("código error = %d\n error printf("uptime = %ds\ncarga 1 min %d / 5 min %d / 15 min %d\n ram total %d / libre </p><h3>#14     19.71085570483779     ../ConsulterRIT/man.es/man2/mprotect.2</h3><h4>Descripcion:</h4><p>mprotect controla forma sección memoria puede ser si acceso no es permitido protección dada programa recibe prot es o-lógico nivel bits siguientes val­ores: prot_none memoria no puede ser accedida ninguna prot_read memoria puede ser prot_write memoria puede ser prot_exec memoria puede contener código nueva protección reemplaza cualquier protección ejemplo si memoria había sido previamente marcada prot_read mprotect se llama entonces prot igual prot_write no se prodrá valor devuelto caso éxito mprotect devuelve caso error se devuelve -1 se asigna errno valor errores einval addr no es puntero válido no es múltiplo efault memoria no puede ser eacces memoria no permite acceso esto puede ocurrir si ejemplo asocia zona memoria mediante mmap(2) fichero al cual sólo tiene acceso lectura pide mpro­tect marque enomem no se han podido reservar estructuras internas del ejemplo #include <stdio.h> #include <stdlib.h> #include <errno.h> #include <sys/mman.h> #include <limits.h> /* pagesize */ #ifndef pagesize #define pagesize 4096 #endif int main(void) { char *p char c /* reserva búffer defecto tendrá protección */ p = malloc(1024+pagesize-1) if !p { perror("malloc imposible reservar 1024 bytes" exit(errno) } /* alinear dirección múltiplo pagesize suponiendo sea potencia 2 */ p = char *)(((int) p + pagesize-1 & ~(pagesize-1)) c = p[666] /* </p><h3>#15     19.423824321072807     ../ConsulterRIT/man.es/man1/bunzip2.1</h3><h4>Descripcion:</h4><p>bzip2 comprime ficheros utilizando algoritmo compre­sión texto ordenación bloques generalmente compresión obtenida es consider­ablemente mejor compresores más convencionales basados lz77/lz78 se aproxima al rendimiento familia ppm compresores opciones línea comandos son deliberadamente muy similares gnu gzip no son bzip2 espera lista nombres acompañe opciones línea cada fichero es reem­plazado copia comprimida él mismo nombre cada fichero comprimido tiene misma fecha modificación permisos original correspondiente forma estas propiedades puedan ser recuperadas correctamente momento manejo nombres ficheros es ingenuo sentido no hay forma preservar nombres originales permisos fechas sistemas ficheros carecen estos conceptos tienen serias restricciones tamaño nombres como ejemplo defecto bzip2 bunzip2 no sobreescribirán ficheros si quieres esto ocurra especifica opción si no se especifica nombre ningún fichero bzip2 comprimirá entrada estándar salida este caso bzip2 se negará escribir salida comprimida terminal ya ésta sería totalmente incomprensible tanto bunzip2 o bzip2 -d descomprime recupera todos ficheros cuyos nombres acaben ficheros este sufijo son al igual antes si no se especifica nombre ningún fichero descompresión se realiza entrada estándar salida bunzip2 descomprimirá correctamente fichero sea concatenación más ficheros resul­ tado es concatenación correspondientes ficheros (-t) se puede comprobar integridad ficheros concatenados también se pueden comprimir descomprimir ficheros salida estándar utilizando opción múltiples </p><h3>#16     19.423824321072807     ../ConsulterRIT/man.es/man1/bzcat.1</h3><h4>Descripcion:</h4><p>bzip2 comprime ficheros utilizando algoritmo compre­sión texto ordenación bloques generalmente compresión obtenida es consider­ablemente mejor compresores más convencionales basados lz77/lz78 se aproxima al rendimiento familia ppm compresores opciones línea comandos son deliberadamente muy similares gnu gzip no son bzip2 espera lista nombres acompañe opciones línea cada fichero es reem­plazado copia comprimida él mismo nombre cada fichero comprimido tiene misma fecha modificación permisos original correspondiente forma estas propiedades puedan ser recuperadas correctamente momento manejo nombres ficheros es ingenuo sentido no hay forma preservar nombres originales permisos fechas sistemas ficheros carecen estos conceptos tienen serias restricciones tamaño nombres como ejemplo defecto bzip2 bunzip2 no sobreescribirán ficheros si quieres esto ocurra especifica opción si no se especifica nombre ningún fichero bzip2 comprimirá entrada estándar salida este caso bzip2 se negará escribir salida comprimida terminal ya ésta sería totalmente incomprensible tanto bunzip2 o bzip2 -d descomprime recupera todos ficheros cuyos nombres acaben ficheros este sufijo son al igual antes si no se especifica nombre ningún fichero descompresión se realiza entrada estándar salida bunzip2 descomprimirá correctamente fichero sea concatenación más ficheros resul­ tado es concatenación correspondientes ficheros (-t) se puede comprobar integridad ficheros concatenados también se pueden comprimir descomprimir ficheros salida estándar utilizando opción múltiples </p><h3>#17     19.423824321072807     ../ConsulterRIT/man.es/man1/bzip2.1</h3><h4>Descripcion:</h4><p>bzip2 comprime ficheros utilizando algoritmo compre­sión texto ordenación bloques generalmente compresión obtenida es consider­ablemente mejor compresores más convencionales basados lz77/lz78 se aproxima al rendimiento familia ppm compresores opciones línea comandos son deliberadamente muy similares gnu gzip no son bzip2 espera lista nombres acompañe opciones línea cada fichero es reem­plazado copia comprimida él mismo nombre cada fichero comprimido tiene misma fecha modificación permisos original correspondiente forma estas propiedades puedan ser recuperadas correctamente momento manejo nombres ficheros es ingenuo sentido no hay forma preservar nombres originales permisos fechas sistemas ficheros carecen estos conceptos tienen serias restricciones tamaño nombres como ejemplo defecto bzip2 bunzip2 no sobreescribirán ficheros si quieres esto ocurra especifica opción si no se especifica nombre ningún fichero bzip2 comprimirá entrada estándar salida este caso bzip2 se negará escribir salida comprimida terminal ya ésta sería totalmente incomprensible tanto bunzip2 o bzip2 -d descomprime recupera todos ficheros cuyos nombres acaben ficheros este sufijo son al igual antes si no se especifica nombre ningún fichero descompresión se realiza entrada estándar salida bunzip2 descomprimirá correctamente fichero sea concatenación más ficheros resul­ tado es concatenación correspondientes ficheros (-t) se puede comprobar integridad ficheros concatenados también se pueden comprimir descomprimir ficheros salida estándar utilizando opción múltiples </p><h3>#18     19.400824243634872     ../ConsulterRIT/man.es/man8/vmstat.8</h3><h4>Descripcion:</h4><p>vmstat da información procesos memoria paginación e/s bloque trampas actividad primer informe producido da medias último adicionales dan información período muestreo longitud cualquier caso informes proceso memoria son opciones opción -n hace cabecera se muestre solamente vez lugar intervalo es período actualizaciones si no se especifica ninguno solamente se muestra informe valores medios número es número si no se especi­fica ninguno sí intervalo número se asume como opción -v resulta mostrar información ver­sión descripciones campos procs r número procesos esperando su tiempo b: número procesos espera w: número procesos espacio trasiego embargo este campo se calcula linux nunca hace trasiego memory swpd cantidad memoria virtual empleada free: cantidad memoria inactiva buff: cantidad memoria empleada como búferes swap si cantidad memoria traída del espacio trasiego disco so: cantidad memoria trasegada al disco io bi bloques enviados dispositivo bloques bo: bloques recibidos dispositivo bloques system in número interrupciones segundo incluyendo al cs: número cambios contexto cpu éstos son porcentajes tiempo total us: tiempo usuario sy tiempo sistema id tiempo inactividad observaciones vmstat no requiere permisos estos informes se entienden ayudar identificar cuellos vmstat linux no se cuenta sí mismo como proceso todos bloques linux son al día fecha 1 kb excepto bloques </p><h3>#19     19.247600651399015     ../ConsulterRIT/man.es/man5/proc.5</h3><h4>Descripcion:</h4><p>/proc es pseudo-sistema ficheros se usa como interfaz estructuras datos del kernel lugar leer interpretar mayor parte este sistema ficheros es sólo lectura algunos ficheros permiten cambiar variables del siguiente resumen proporciona rápida visita jerarquía [number] hay subdirectorio numérico cada proceso ejecución nombre del subdirectorio es id del cada ellos contiene siguientes pseudo ficheros cmdline este contiene línea comandos completa proceso menos proceso entero se haya intercambiado disco menos proceso sea proceso cualquiera estos dos últimos casos no hay nada fichero es decir lectura este fichero regresará como si hubiera leído 0 este fichero termina carácter nulo no carácter nueva cwd este es enlace directorio trabajo actual del ejemplo encontrar directorio trabajo actual del proceso 20 puede hacer esto cd /proc/20/cwd /bin/pwd dese cuenta orden pwd es frecuentemente orden interna del shell podría no funcionar adecuadamente este environ este fichero contiene entorno del entradas están serparadas caracteres nulos podría haber carácter nulo al tanto mostrar entorno del proceso 1 debería hacer cat /proc/1/environ echo | tr \000 \n una razón alguien querría hacer esto puede encontrar lilo(8).) exe puntero al fichero binario fue ejecutado aparece com enlace función readlink(2) aplicada al fichero especial exe devuelve linux 2.0 versiones anteriores cadena </p><h3>#20     19.2474270689264     ../ConsulterRIT/man.es/man2/readv.2</h3><h4>Descripcion:</h4><p>readv lee datos descriptor fichero fd pone resultados zona memoria descrita número bloques memoria se especifica bloques se llenan orden funciona igual read salvo datos son puestos vector lugar zona contigua writev escribe datos al descriptor fichero fd zona memoria descrita número blo­ques memoria se especifica bloques son usados orden funciona igual write excepto datos son tomados vector lugar zona contigua valor devuelto caso éxito readv devuelve número bytes caso éxito writev devuelve número bytes caso error se devuelve -1 se asigna errno valor errores einval se ha dado argumento ejemplo count podría ser mayor max_iovec fd podría estar unido objeto inadecuado lectura para readv escritura para efault fallo probablemente vector alguno punteros iov_base apuntan zona memoria no está correctamente ebadf descriptor fichero fd no es eintr llamada ha sido interrumpida señal antes algún dato fuese eagain se ha seleccionado e/s no bloqueante usando o_non­block no había datos disponibles inmediatamente ser (o descriptor fichero fd apunta objeto está eisdir fd hace referencia eopnotsup fd hace referencia socket dispositivo no soporta enomem no hay suficiente memoria del núcleo podrían ocurrir otros errores dependiendo del objeto conectado conforme 4.4bsd las funciones readv writev aparecieron primeras vez bsd 4.2 libc5 linux usa size_t </p><h3>#21     19.2474270689264     ../ConsulterRIT/man.es/man2/writev.2</h3><h4>Descripcion:</h4><p>readv lee datos descriptor fichero fd pone resultados zona memoria descrita número bloques memoria se especifica bloques se llenan orden funciona igual read salvo datos son puestos vector lugar zona contigua writev escribe datos al descriptor fichero fd zona memoria descrita número blo­ques memoria se especifica bloques son usados orden funciona igual write excepto datos son tomados vector lugar zona contigua valor devuelto caso éxito readv devuelve número bytes caso éxito writev devuelve número bytes caso error se devuelve -1 se asigna errno valor errores einval se ha dado argumento ejemplo count podría ser mayor max_iovec fd podría estar unido objeto inadecuado lectura para readv escritura para efault fallo probablemente vector alguno punteros iov_base apuntan zona memoria no está correctamente ebadf descriptor fichero fd no es eintr llamada ha sido interrumpida señal antes algún dato fuese eagain se ha seleccionado e/s no bloqueante usando o_non­block no había datos disponibles inmediatamente ser (o descriptor fichero fd apunta objeto está eisdir fd hace referencia eopnotsup fd hace referencia socket dispositivo no soporta enomem no hay suficiente memoria del núcleo podrían ocurrir otros errores dependiendo del objeto conectado conforme 4.4bsd las funciones readv writev aparecieron primeras vez bsd 4.2 libc5 linux usa size_t </p><h3>#22     19.111513043987305     ../ConsulterRIT/man.es/man3/stdio.3</h3><h4>Descripcion:</h4><p>biblioteca e/s estándar proporciona interface corriente stream utilizando sistema buffers memo­ria intermedia simple entrada salida se mapean corrientes logicas datos caracteris­ticas fisicas e/s permanecen ocultas funciones macros se muestran mas ade­lante; mas información se puede recurrir pagi­nas del manual individuales cada corriente se asocia archivo externo el cual debe estar dispositivo físico abriendo archivo cual se supone debe ser crear archivo existente hara dicho archivo quede si archivo soporta posicionamiento como archivo disco contraposición ocurre archivo ter­minal) entonces marcador posición asociado cor­riente se situara al principio del archivo byte cero no ser archivo sea abierto modo añadir si se utiliza esta última modalidad apertura mar­cador posición será situado al final del indicador posicion se mantiene sucesivas lecturas escrituras todas entradas se hacen como si caracteres hubieran sido leidos mediante sucesivas llamadas función fgetc(3) todas salidas se producen como si todos caracteres fueran leidos mediante llamadas sucesivas función fputc(3) archivo se desentiende corriente cerrando dicho corrientes salida son descargadas toda contenido memoria intermedia no fue escrita al archivo se transmite ese momento antes cor­riente se desentienda del valor puntero apunta objeto file es indeterminado cierre del archivo sera reabierto repitidamente misma otras ejecuciones programa sus contenidos seran leidos modificados si se </p><h3>#23     18.896296751071755     ../ConsulterRIT/man.es/man2/mmap.2</h3><h4>Descripcion:</h4><p>función mmap intenta ubicar length bytes comenzando desplazamiento offset fichero u otro objeto espeficicado fd memoria preferiblemente dirección esta última dirección es sugerencia normalmente se especifica como lugar donde es ubicado objeto es devuelto argumento prot describe protección memoria forman siguientes bits prot_exec páginas deben ser prot_read páginas deben ser prot_write páginas deben ser prot_none páginas no pueden ser parámetro flags especifica tipo objeto insertado opciones asociación si modificaciones hechas copia insertada memoria son privadas al proceso son compartidas otras tiene bits map_fixed no seleccionar dirección diferente si dirección especificada no puede ser utilizada mmap si map_fixed es especificado start debe ser múltiplo del tamaño utilizar esta opción es map_shared comparte este área todos otros objetos señalan este map_private crear área privada debe especificarse exactamente parámetros map_shared tres parámetros anteriores están descritos posix.1b formalmente linux también reconoce map_deny­write map_executable llamada al sistema munmap borra ubicaciones rango direcciones especificado produce referencias direcciones dentro del rango fin generar referen­cias memoria valor devuelto si ha funcionado mmap devuelve puntero al área caso error es devuelto -1 errno es modi­ficado si ha funcionado munmap devuelve 0 si hay error -1 errno es fijada probablemente errores ebadf fd no es descriptor fichero válido y map_anonymous </p><h3>#24     18.896296751071755     ../ConsulterRIT/man.es/man2/munmap.2</h3><h4>Descripcion:</h4><p>función mmap intenta ubicar length bytes comenzando desplazamiento offset fichero u otro objeto espeficicado fd memoria preferiblemente dirección esta última dirección es sugerencia normalmente se especifica como lugar donde es ubicado objeto es devuelto argumento prot describe protección memoria forman siguientes bits prot_exec páginas deben ser prot_read páginas deben ser prot_write páginas deben ser prot_none páginas no pueden ser parámetro flags especifica tipo objeto insertado opciones asociación si modificaciones hechas copia insertada memoria son privadas al proceso son compartidas otras tiene bits map_fixed no seleccionar dirección diferente si dirección especificada no puede ser utilizada mmap si map_fixed es especificado start debe ser múltiplo del tamaño utilizar esta opción es map_shared comparte este área todos otros objetos señalan este map_private crear área privada debe especificarse exactamente parámetros map_shared tres parámetros anteriores están descritos posix.1b formalmente linux también reconoce map_deny­write map_executable llamada al sistema munmap borra ubicaciones rango direcciones especificado produce referencias direcciones dentro del rango fin generar referen­cias memoria valor devuelto si ha funcionado mmap devuelve puntero al área caso error es devuelto -1 errno es modi­ficado si ha funcionado munmap devuelve 0 si hay error -1 errno es fijada probablemente errores ebadf fd no es descriptor fichero válido y map_anonymous </p><h3>#25     18.885100336439404     ../ConsulterRIT/man.es/man4/kmem.4</h3><h4>Descripcion:</h4><p>mem es fichero dispositivo caracteres repre­senta memoria principal del se puede uti­lizar ejemplo examinar e incluso parchear mem direcciones bytes se interpretan como direcciones físicas referencias posi­ciones no existentes producen examinar parchear posiciones memoria contienen bits sólo-lectura sólo-escritura puede conducir resultados normalmente se crea con mknod -m 660 /dev/mem c 1 1 chown root:mem /dev/mem archivo kmem es idéntico mem excepto se accede memoria virtual del núcleo vez memoria normalmente se crea con mknod -m 640 /dev/kmem c 1 2 chown root:mem /dev/kmem port es similar mem se accede puertos normalmente se crea con mknod -m 660 /dev/port c 1 4 chown root:mem /dev/port ficheros /dev/mem /dev/kmem /dev/port véase también mknod(1) chown(1) ioperm(2) linux 21 noviembre 1992 mem(4) </p><h3>#26     18.885100336439404     ../ConsulterRIT/man.es/man4/mem.4</h3><h4>Descripcion:</h4><p>mem es fichero dispositivo caracteres repre­senta memoria principal del se puede uti­lizar ejemplo examinar e incluso parchear mem direcciones bytes se interpretan como direcciones físicas referencias posi­ciones no existentes producen examinar parchear posiciones memoria contienen bits sólo-lectura sólo-escritura puede conducir resultados normalmente se crea con mknod -m 660 /dev/mem c 1 1 chown root:mem /dev/mem archivo kmem es idéntico mem excepto se accede memoria virtual del núcleo vez memoria normalmente se crea con mknod -m 640 /dev/kmem c 1 2 chown root:mem /dev/kmem port es similar mem se accede puertos normalmente se crea con mknod -m 660 /dev/port c 1 4 chown root:mem /dev/port ficheros /dev/mem /dev/kmem /dev/port véase también mknod(1) chown(1) ioperm(2) linux 21 noviembre 1992 mem(4) </p><h3>#27     18.885100336439404     ../ConsulterRIT/man.es/man4/port.4</h3><h4>Descripcion:</h4><p>mem es fichero dispositivo caracteres repre­senta memoria principal del se puede uti­lizar ejemplo examinar e incluso parchear mem direcciones bytes se interpretan como direcciones físicas referencias posi­ciones no existentes producen examinar parchear posiciones memoria contienen bits sólo-lectura sólo-escritura puede conducir resultados normalmente se crea con mknod -m 660 /dev/mem c 1 1 chown root:mem /dev/mem archivo kmem es idéntico mem excepto se accede memoria virtual del núcleo vez memoria normalmente se crea con mknod -m 640 /dev/kmem c 1 2 chown root:mem /dev/kmem port es similar mem se accede puertos normalmente se crea con mknod -m 660 /dev/port c 1 4 chown root:mem /dev/port ficheros /dev/mem /dev/kmem /dev/port véase también mknod(1) chown(1) ioperm(2) linux 21 noviembre 1992 mem(4) </p><h3>#28     18.71249623296737     ../ConsulterRIT/man.es/man2/uselib.2</h3><h4>Descripcion:</h4><p>uselib selecciona fichero binario biblioteca compartida será empleado este valor devuelto caso éxito se devuelve caso error se devuelve -1 se pone errno valor errores además todos códigos error devueltos open(2) mmap(2) también pueden devolverse siguientes enoexec fichero especificado biblioteca no es eje­cutable no posee números mágicos eacces biblioteca especificada biblioteca no tiene permiso conforme uselib() es específica linux no debería emplearse programas se pretendan véase también open(2) mmap(2) ldd(1) gcc(1) ar(1) ld(1) linux 0.99.11 9 febrero 1998 uselib(2) <unistd h> </p><h3>#29     18.580057677879974     ../ConsulterRIT/man.es/man3/recno.3</h3><h4>Descripcion:</h4><p>ruinta dbopen es interfaz biblioteca ficheros bases formatos fichero soportados es ficheros registros numerados que llamaremos descripción general métodos acceso bases datos se encuentra página manual dbopen(3) esta página manual sólo describe información específica estructura datos registros numerados está formada registros longitud fija variable almacenados formato fichero plano accedido número lógico existencia del registro número cinco implica existencia registros del 1 al 5 eliminación del registro número 1 hace registro número 5 sea renumerado al registro número 4 misma manera cursor se desplazará registro abajo si se encuentra posicionado después del registro número estructura datos específica del método acceso regnum proporcionada dbopen se define fichero cabecera <db.h> como sigue typedef struct { u_long flags u_int cachesize u_int psize int lorder size_t reclen u_char bval char *bfname } recnoinfo elementos esta estructura se definen sigu­iente manera flags valor opciones se especifica mediante operación o-lógica cualquiera siguientes valores r_fixedlen registros son longitud fija no delimitados elemento reclen estructura especifica longitud del registro elemento bval estructura se usa como carácter todos registros insertados base datos cuya longitud es más pequeña reclen bytes se completan automáticamente carácter r_nokey interfaz especificada dbopen recuperación secuencial registros rellena tanto clave del invocador como estructuras si se especifica </p><h3>#30     18.534014014812392     ../ConsulterRIT/man.es/man3/memmove.3</h3><h4>Descripcion:</h4><p>función memmove() copia n bytes del área memoria src al área memoria áreas memoria pueden valor devuelto función memmove() devuelve puntero conforme svid 3 bsd 4.3 iso 9899 véase también bcopy(3) memccpy(3) memcpy(3) strcpy(3) strncpy(3) gnu 10 abril 1993 memmove(3) <string h> </p></body></html>