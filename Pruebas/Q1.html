<html><head><title>Consulta: colas de mensajes para la comunicación entre procesos</title></head><body><h3>#1     33.46355595797097     ../ConsulterRIT/man.es/man7/rtnetlink.7</h3><h4>Descripcion:</h4><p>rtnetlink permite leer alterar tablas enrutamiento del se usa dentro del núcleo comunicar sí varios subsistemas aunque este uso no se documenta aquí comunicación programas espacio rutas red direcciones ip parámetros enlace configuraciones veci­nos disciplinas encolamiento clases inter­cambio clasificadores paquetes pueden controlarse través conectores todo esto se basa mensajes vea netlink(7) más atributos enrutamiento algunos mensajes rtnetlink poseen atributos opcionales después cabecera inicial struct rtattr { unsigned short rta_len /* longitud opción */ unsigned short rta_type /* tipo opción */ /* datos vienen continuación */ } estos atributos sólo deberían manipularse usando macros rta_* librería vea mensajes rtnetlink está formado siguientes tipos men­sajes además mensajes netlink estándares rtm_newlink rtm_dellink rtm_getlink crea borra obtiene información interfaz red estos mensajes contienen estructura ifinfomsg seguida serie estructuras struct ifinfomsg { unsigned char ifi_family /* af_unspec */ unsigned char __ifi_pad /* usar */ unsigned short ifi_type /* tipo del dispositivo */ int ifi_index /* índice interfaz */ unsigned int ifi_flags /* opciones del dispositivo */ unsigned int ifi_change /* máscara cambios */ } ifi_flags contiene opciones del vea ifi_index es índice ifi_change se reserva uso futuro siempre debe valer +-------------------------------------------------------------+ | atributos enrutamiento | +---------------+--------------------+------------------------+ |rta_type | tipo valor | descripción | +---------------+--------------------+------------------------+ |ifla_unspec </p><h3>#2     31.67317379117301     ../ConsulterRIT/man.es/man1/skill.1</h3><h4>Descripcion:</h4><p>skill envía señal terminate conjunto si se da nombre  número  señal precedido esa señal se sustituirá comando skill -l muestra lista señales snice altera prioridad establecida conjunto procesos defecto nueva prioridad será +4 se puede usar argumento del tipo +n ó -n" especificar valores cualquier pri­oridad no válida será redondeada ascendente descendente­mente llegar al primer valor opciones aceptadas ambos comandos son sigu­ientes: -i modo interactivo se consulta al usuario cada proceso candidato al respon­der y se ejecutará acción otra parte ^d hace skill snice se cierren -v modo información ampliada se muestra id cada proceso se ha actuado -f modo rápido se permite al código dependiente máquina responsable lectura pro­cesos tome decisiones contribuyan mejorar velocidad expensas información errores por ejemplo es posible no se muestren esta opción existe principalmente ayudar eliminar procesos fuera control sistemas diseños vm -w muestra mensajes advertencia procesos -n muestra ids del proceso no actúa todos argumentos línea comandos son indepen­dientes cuanto su skill snice permiten procesos se especifiquen usando cualquier combinación ttys nombres usuario comandos además ids sólo se actúa procesos coincidan algo cada categoría vacía asegura ejemplo skill -hup vi ex tty00 enviará señal hangup todos procesos vi(1) ex(1) asociados del mismo </p><h3>#3     31.67317379117301     ../ConsulterRIT/man.es/man1/snice.1</h3><h4>Descripcion:</h4><p>skill envía señal terminate conjunto si se da nombre  número  señal precedido esa señal se sustituirá comando skill -l muestra lista señales snice altera prioridad establecida conjunto procesos defecto nueva prioridad será +4 se puede usar argumento del tipo +n ó -n" especificar valores cualquier pri­oridad no válida será redondeada ascendente descendente­mente llegar al primer valor opciones aceptadas ambos comandos son sigu­ientes: -i modo interactivo se consulta al usuario cada proceso candidato al respon­der y se ejecutará acción otra parte ^d hace skill snice se cierren -v modo información ampliada se muestra id cada proceso se ha actuado -f modo rápido se permite al código dependiente máquina responsable lectura pro­cesos tome decisiones contribuyan mejorar velocidad expensas información errores por ejemplo es posible no se muestren esta opción existe principalmente ayudar eliminar procesos fuera control sistemas diseños vm -w muestra mensajes advertencia procesos -n muestra ids del proceso no actúa todos argumentos línea comandos son indepen­dientes cuanto su skill snice permiten procesos se especifiquen usando cualquier combinación ttys nombres usuario comandos además ids sólo se actúa procesos coincidan algo cada categoría vacía asegura ejemplo skill -hup vi ex tty00 enviará señal hangup todos procesos vi(1) ex(1) asociados del mismo </p><h3>#4     31.47926476115041     ../ConsulterRIT/man.es/man5/proc.5</h3><h4>Descripcion:</h4><p>/proc es pseudo-sistema ficheros se usa como interfaz estructuras datos del kernel lugar leer interpretar mayor parte este sistema ficheros es sólo lectura algunos ficheros permiten cambiar variables del siguiente resumen proporciona rápida visita jerarquía [number] hay subdirectorio numérico cada proceso ejecución nombre del subdirectorio es id del cada ellos contiene siguientes pseudo ficheros cmdline este contiene línea comandos completa proceso menos proceso entero se haya intercambiado disco menos proceso sea proceso cualquiera estos dos últimos casos no hay nada fichero es decir lectura este fichero regresará como si hubiera leído 0 este fichero termina carácter nulo no carácter nueva cwd este es enlace directorio trabajo actual del ejemplo encontrar directorio trabajo actual del proceso 20 puede hacer esto cd /proc/20/cwd /bin/pwd dese cuenta orden pwd es frecuentemente orden interna del shell podría no funcionar adecuadamente este environ este fichero contiene entorno del entradas están serparadas caracteres nulos podría haber carácter nulo al tanto mostrar entorno del proceso 1 debería hacer cat /proc/1/environ echo | tr \000 \n una razón alguien querría hacer esto puede encontrar lilo(8).) exe puntero al fichero binario fue ejecutado aparece com enlace función readlink(2) aplicada al fichero especial exe devuelve linux 2.0 versiones anteriores cadena </p><h3>#5     28.593088448013017     ../ConsulterRIT/man.es/man8/atd.8</h3><h4>Descripcion:</h4><p>atd ejecuta comandos encolados opciones -l especifica factor limitador carga encima del cual trabajos lotes no deberían ejecutarse vez elección tiempo compilación sistema smp n cpus probablemente se desee poner esto más alto -b especifica mínimo intérvalo segundos comienzo dos procesos lotes 60 -d debug imprime mensajes error salida estándar error vez usar -s procesa cola at/por_lotes sola esto se usa principalmente compatibilidad ver­siones antiguas at atd -s es equivalente antigua orden compatibilidad existe /usr/sbin/atrun es guión shell ejecuta atd ficheros /var/spool/cron/atjobs directorio almacenar traba­jos; debería tener modo 700 propietario /var/spool/cron/atspool directorio almacenar salida debería tener modo 700 propietario /etc/at.allow /etc/at.deny determina quién puede usar sistema véase también at(1) atrun(1) cron(1) crontab(1) syslog(3) at_deny(5) at_allow(5) fallos funcionalidad atd debería estar incluida dentro local marzo 1997 atd(8) /etc/at deny </p><h3>#6     19.273784412982643     ../ConsulterRIT/man.es/man7/hier.7</h3><h4>Descripcion:</h4><p>jerarquía del sistema descripción sistema linux típico tiene otros siguientes directorios / este es directorio aquí comienza todo árbol /bin este directorio contiene programas ejecutables son necesarios modo monousuario arranque reparación del /boot contiene ficheros estáticos cargador arranque boot este directorio contiene sólo ficheros necesarios durante proceso instalador del mapa arranque ficheros configuracion deberían estar /sbin /dev ficheros especiales dispositivo se refieren dispositivos ver /dos si se utilizan tanto ms-dos como linux mismo ordenador éste es lugar típico montar sistema ficheros /etc contiene ficheros configuración locales algunos paquetes software más grandes como x11 pueden tener sus propios subdirectorios ficheros configuración generales pueden colocarse aquí no obstante programas siempre deberían buscar estos ficheros /etc algunos cuales podrían ser enlaces ficheros /etc/skel cuando se crea nueva cuenta usuario normal­mente se copian ficheros este directorio al directorio del usuario directorio /etc/x11 ficheros configuración del sistema ventanas /home normalmente máquinas poseen directorios home usuarios éstos se hallan este directorio sea directa estructura este directorio depende decisiones administrativas /lib este directorio debe contener aquellas bibliotecas compartidas son necesarias arrancar sistema ejecutar órdenes del sistema ficheros /mnt es punto montaje sistemas ficheros montados /proc este es punto montaje sistema ficheros proc proporciona información acerca procesos ejecución </p><h3>#7     18.664314673805585     ../ConsulterRIT/man.es/man3/closelog.3</h3><h4>Descripcion:</h4><p>closelog() cierra descriptor se esté usando escribir registrador del empleo closelog() es openlog() abre programa conexión reg­istrador del cadena caracteres apunte ident se añade cada mensaje normalmente se hace contenga nombre del valores opcion facilidad se dan sección empleo openlog() es opcional syslog() llamaría automáticamente si fuera menester cuyo caso ident tomaría valor syslog() genera mensaje registro será dis­tribuido prioridad es combinación facilidad nivel cuyos valores se dan sección restantes argumentos son formato for­mat como printf(3) cualesquiera argumentos requeri­dos format salvo dos caracteres %m serán reemplazados cadena mensaje error str­error) correspondiente al valor actual parámetros esta sección enumera parámetros empleados poner valores opcion facilidad opcion argumento opcion openlog() es resultado combinación operador bits inclusivo cualquiera estos valoes log_cons escribe directamente consola del sistema si hay error mientras se está enviando algo al reg­istrador del sistema log_ndelay abre conexión inmediatamente normalmente conexión se abre cuando se registra primer men­saje) log_perror imprime también stderr log_pid incluye pid cada mensaje facilidad argumento facilidad se emplea especificar qué tipo programa está registrando esto permite fichero configuración se especifique mensajes diferentes programas se manejen forma log_auth mensajes seguridad autorización desaprobado emplee su lugar log_authpriv log_authpriv mensajes seguridad autorización privado log_cron duende del reloj cron at </p><h3>#8     18.664314673805585     ../ConsulterRIT/man.es/man3/openlog.3</h3><h4>Descripcion:</h4><p>closelog() cierra descriptor se esté usando escribir registrador del empleo closelog() es openlog() abre programa conexión reg­istrador del cadena caracteres apunte ident se añade cada mensaje normalmente se hace contenga nombre del valores opcion facilidad se dan sección empleo openlog() es opcional syslog() llamaría automáticamente si fuera menester cuyo caso ident tomaría valor syslog() genera mensaje registro será dis­tribuido prioridad es combinación facilidad nivel cuyos valores se dan sección restantes argumentos son formato for­mat como printf(3) cualesquiera argumentos requeri­dos format salvo dos caracteres %m serán reemplazados cadena mensaje error str­error) correspondiente al valor actual parámetros esta sección enumera parámetros empleados poner valores opcion facilidad opcion argumento opcion openlog() es resultado combinación operador bits inclusivo cualquiera estos valoes log_cons escribe directamente consola del sistema si hay error mientras se está enviando algo al reg­istrador del sistema log_ndelay abre conexión inmediatamente normalmente conexión se abre cuando se registra primer men­saje) log_perror imprime también stderr log_pid incluye pid cada mensaje facilidad argumento facilidad se emplea especificar qué tipo programa está registrando esto permite fichero configuración se especifique mensajes diferentes programas se manejen forma log_auth mensajes seguridad autorización desaprobado emplee su lugar log_authpriv log_authpriv mensajes seguridad autorización privado log_cron duende del reloj cron at </p><h3>#9     18.664314673805585     ../ConsulterRIT/man.es/man3/syslog.3</h3><h4>Descripcion:</h4><p>closelog() cierra descriptor se esté usando escribir registrador del empleo closelog() es openlog() abre programa conexión reg­istrador del cadena caracteres apunte ident se añade cada mensaje normalmente se hace contenga nombre del valores opcion facilidad se dan sección empleo openlog() es opcional syslog() llamaría automáticamente si fuera menester cuyo caso ident tomaría valor syslog() genera mensaje registro será dis­tribuido prioridad es combinación facilidad nivel cuyos valores se dan sección restantes argumentos son formato for­mat como printf(3) cualesquiera argumentos requeri­dos format salvo dos caracteres %m serán reemplazados cadena mensaje error str­error) correspondiente al valor actual parámetros esta sección enumera parámetros empleados poner valores opcion facilidad opcion argumento opcion openlog() es resultado combinación operador bits inclusivo cualquiera estos valoes log_cons escribe directamente consola del sistema si hay error mientras se está enviando algo al reg­istrador del sistema log_ndelay abre conexión inmediatamente normalmente conexión se abre cuando se registra primer men­saje) log_perror imprime también stderr log_pid incluye pid cada mensaje facilidad argumento facilidad se emplea especificar qué tipo programa está registrando esto permite fichero configuración se especifique mensajes diferentes programas se manejen forma log_auth mensajes seguridad autorización desaprobado emplee su lugar log_authpriv log_authpriv mensajes seguridad autorización privado log_cron duende del reloj cron at </p><h3>#10     18.6064905946997     ../ConsulterRIT/man.es/man8/renice.8</h3><h4>Descripcion:</h4><p>renice altera prioridad planificación más procesos siguientes parámetros quién son interpretados como id's proceso id's grupo proceso nombres aplicar renice grupo procesos provoca todos procesos del grupo procesos vean alterada su prioridad aplicar renice usuario hace todos sus procesos vean prioridad planificación defecto procesos se especifican partir su id opciones soportadas renice son -g forzar parámetros quién sean interpretados como id's grupo -u forzar parámetros quién sean interpretados como nombres -p reinicia interpretación quién sea id pro­ceso por ejemplo renice +1 987 -u daemon root -p 32 cambiaría prioridad procesos id 987 32 todos pro­cesos usuarios daemon cada usuario excepto superusuario sólo podrá alterar prioridad sus procesos solo podrá incrementar su ``valor nice'' rango 0 prio_max (esto evita saltarse mandatos superusuario podrá modificar prioridad cualquier proceso poner prioridad cualquier valor rango prio_min -20 pri­ oridades útiles son 20 los procesos afectados solo correrán cuando ningún otro desee sistema 0 la prioridad planificación ``base'' cualquier cosa negativa para hacer cosas vayan ficheros /etc/passwd mapear nombres usuarios su véase también getpriority(2) setpriority(2) fallos usuarios normales no pueden incrementar prioridad sus procesos aunque decrementaran ellos mismos kernel linux por menos versión 2.0.0 libc linux por menos versión 5.2.18 no concuerdan completamente quiere decir </p><h3>#11     18.605960507339116     ../ConsulterRIT/man.es/man8/ipcs.8</h3><h4>Descripcion:</h4><p>ipcs proporciona información recursos del ipc cuales proceso llama tiene acceso opción -i permite se especifique id recurso sólo se mostrará información id se recursos se pueden especificar tal como sigue -m segmentos memoria compartida -q colas mensajes -s matrices semáforos -a todos esta es opción defecto formato salida se puede especificar sigu­ientes maneras -t tiempo -p pid identificador proceso -c creador -l límites -u sumario véase también ipcrm(8) autor krishna balasubramanian balasub@cis.ohio-state.edu linux 0.99 9 octubre 1993 ipcs(8) balasub@cis ohio-state edu </p><h3>#12     18.550813797200277     ../ConsulterRIT/man.es/man1/top.1</h3><h4>Descripcion:</h4><p>top proporciona visión continuada actividad del procesador tiempo muestra listado tar­eas hacen uso más intensivo cpu sis­tema puede proporcionar interfaz interactiva manipular puede clasificar tareas empleo cpu uso memoria tiempo puede con­figurarse mejor top normal del conjunto progra­mas mayoría características pueden seleccionarse mediante orden interactiva especi­ficándola fichero configuración personal hay más información esto más opciones línea órdenes d especifica intervalo actualizaciones esto puede cambiarse orden interac­tiva q esto hace top redibuje pantalla intervalo si ejecuta programa tiene privile­gios súper-usuario top se ejecuta priori­dad más alta s especifica modo acumulativo donde cada proceso se lista tiempo cpu él así como sus hijos muertos ha esto es como opción -s vea discusión más abajo orden interactiva s dice top se ejecute modo esto inhabilita peligro potencial órdenes inter­activas vea más top seguro es cosa curiosa dejar ejecutándose terminal i arranca top descartando cualquier proceso inactivo vea más abajo orden interactiva c muestra línea órdenes entera lugar sola­mente nombre comportamiento prede­terminado se ha cambiado puesto esto parece ser más descripciones campos top despliega variada información estado del pantalla se actualiza cada 5 segundos forma predeterminada esto se puede cambiar opción línea órdenes d orden interactiva uptime esta línea muestra tiempo sistema ha estado </p><h3>#13     18.53835181839888     ../ConsulterRIT/man.es/man2/clone.2</h3><h4>Descripcion:</h4><p>__clone crea nuevo proceso como hace diferencia fork(2) __clone permite al proceso hijo compartir partes su contexto ejecución su pro­ceso padre tales como espacio memoria tabla descriptores fichero tabla manejadores principal uso __clone es implementar hilos múltiples hilos control programa se ejecutan concurrentemente espacio memoria cuando se crea proceso hijo éste ejecuta función argumento fn es puntero función es ejecutada proceso hijo al comienzo su argumento arg se pasa función cuando función fn(arg) regresa proceso hijo entero devuelto fn es código salida del proceso proceso hijo también puede terminar explícitamente ejecutando exit(1) después recibir señal argumento child_stack indica posición pila utilizada proceso aunque procesos padre hijo pueden compartir memoria no es posible gen­eral proceso hijo ejecutarse usando misma pila proceso tanto proceso padre debe preparar área memoria pila del hijo pasar puntero dicha área pilas crecen abajo todos procesadores se ejecuta linux excepto procesador hp pa child_stack apunta normalmente dirección más alta zona memoria preparada pila del byte flags contiene número señal envi­ada al padre cuando hijo flags puede también ser operado or nivel bits bitwise or varias siguientes constantes así especi­ficar qué van compartir procesos padre hijo clone_vm si se pone clone_vm procesos padre hijo se ejecutan mismo espacio </p><h3>#14     18.42760710122716     ../ConsulterRIT/man.es/man3/insque.3</h3><h4>Descripcion:</h4><p>insque() remque() son funciones manipular colas hechas partir listas doblemente cada ele­mento esta lista es tipo struct estructura qelem se define como struct qelem { struct qelem *q_forw struct qelem *q_back char q_data[1] } insque() inserta elemento apuntado elem inmediata­mente detrás del elemento apuntado prev no debe ser remque() quita elemento apuntado elem lista doblemente conforme svr4 fallos campo q_data se define algunas veces como tipo char * solaris 2.x no parece exista localización prototipos estas funciones difiere según diversas versiones algunos sis­temas ponen <search.h> otros linux pone <stdlib.h> puesto es sitio donde pare­cen tener mayor algunas versiones unix como hp-ux 10.x no definen struct qelem sino argumentos insque() remque() son tipo void gnu 27 febrero 1998 insque(3) <stdlib h> x <search h> <stdlib h> x </p><h3>#15     18.42760710122716     ../ConsulterRIT/man.es/man3/remque.3</h3><h4>Descripcion:</h4><p>insque() remque() son funciones manipular colas hechas partir listas doblemente cada ele­mento esta lista es tipo struct estructura qelem se define como struct qelem { struct qelem *q_forw struct qelem *q_back char q_data[1] } insque() inserta elemento apuntado elem inmediata­mente detrás del elemento apuntado prev no debe ser remque() quita elemento apuntado elem lista doblemente conforme svr4 fallos campo q_data se define algunas veces como tipo char * solaris 2.x no parece exista localización prototipos estas funciones difiere según diversas versiones algunos sis­temas ponen <search.h> otros linux pone <stdlib.h> puesto es sitio donde pare­cen tener mayor algunas versiones unix como hp-ux 10.x no definen struct qelem sino argumentos insque() remque() son tipo void gnu 27 febrero 1998 insque(3) <stdlib h> x <search h> <stdlib h> x </p><h3>#16     18.108482441774658     ../ConsulterRIT/man.es/man3/killpg.3</h3><h4>Descripcion:</h4><p>función killpg() hace se envíe señal signal todos procesos del grupo procesos pidgrp procesos del propio grupo procesos si pidgrp es igual es equivalente kill(-pidgrp signal valor devuelto valor devuelto es -1 caso error ó 0 caso acabar errores errores se devuelven variable global errno pueden ser siguientes einval señal inválida esrch grupo procesos no existe eperm si uid del proceso hace llamado no es igual al del proceso al se envía señal uid no es del conforme no se véase también kill(2) signal(2) signal(7) gnu 2 marzo 1998 killpg(3) <signal h> </p><h3>#17     18.074553753243332     ../ConsulterRIT/man.es/man2/setsid.2</h3><h4>Descripcion:</h4><p>setsid() crea nueva sesión si proceso realiza llamada no es lider grupo proceso realiza llamada es lider nueva sesión lider grupo procesos del nuevo grupo procesos no tiene terminal id del grupo procesos id sesión del proceso realiza llamada se ponen al pid del proceso realiza dicho proceso será único proceso este nuevo grupo pro­cesos esta nueva valor regresado id sesión del proceso realiza errores si hubo error se devuleve único error puede suceder es se devuelve cuando id del grupo procesos cualquier proceso es igual al pid del proceso realiza este modo particular set­sid falla si proceso realiza llamada ya es lider grupo notas lider grupo procesos es proceso id grupo igual su asegurarse setsid tenga éxito cree proceso hijo fork termine deje hijo ejecute conforme posix véase también setpgid(2) setpgrp(2) linux 1.0.0 27 agosto 1994 setsid(2) <unistd h> </p><h3>#18     17.976102601967792     ../ConsulterRIT/man.es/man2/kill.2</h3><h4>Descripcion:</h4><p>llamada kill se puede usar enviar cualquier señal proceso grupo si pid es positivo entonces señal sig es enviada este caso se devuelve 0 si hay éxito valor negativo si hay si pid es 0 entonces sig se envía cada proceso grupo procesos del proceso si pid es igual -1 entonces se envía sig cada pro­ceso excepto al primero números más altos tabla procesos más si pid es menor -1 entonces se envía sig cada pro­ceso grupo procesos si sig es 0 entonces no se envía ninguna señal todavía se realiza comprobación valor devuelto si hay éxito se devuelve si hay error se devuelve -1 se actualiza errno errores einval se especificó señal esrch pid grupo procesos no nótese proceso existente podría ser zombi proceso ya ha sido terminado aún no ha sido eperm proceso no tiene permiso enviar señal alguno procesos proceso tenga permiso enviar señal al proceso pid debe bien tener privilegios root bien id usuario real efectivo del proceso envía señal ha ser igual al set-user-id real guardado del proceso fallos es imposible enviar señal tarea número proceso init no ha sido instalado mane­jador esto se hace asegurarse sistema no se venga abajo conforme svr4 svid posix.1 </p><h3>#19     17.784560317403844     ../ConsulterRIT/man.es/man2/recv.2</h3><h4>Descripcion:</h4><p>llamadas recvfrom recvmsg se emplean recibir mensajes conector ``socket'' pueden uti­lizarse recibir datos conector sea orientado conexión si no es null conector no es orientado conex­ión dirección fuente del mensaje se argu­ mento londesde es parámetro referencia inicial­izado al tamaño del búfer asociado modificado cuando función regresa indicar tamaño real dirección guardada llamada recv se utiliza normalmente sólo conec­tor conectado vea connect(2)) es idéntica recvfrom parámetro valor tres rutinas devuelven longitud del mensaje cuando terminan si mensaje es demasiado largo como caber búfer suministrado bytes sobran pueden descartarse dependiendo del tipo conector del se reciba mensaje vea si no hay mensajes disponibles conector lla­madas recepción esperan llegue mensaje menos conector sea no bloqueante vea fcntl(2)) cuyo caso se devuelve valor -1 variable externa errno toma valor llamadas recepción devuelven normalmente cualquier dato disponible cantidad pedida vez esperar recepción cantidad pedida completa este comportamiento se ve afectado opciones del nivel conectores so_rcvlowat so_rcv­timeo descritas llamadas select(2) poll(2) pueden emplearse determinar cuándo llegan más argumento flags llamada recv se forma apli­cando operador bits o-lógico más val­ores siguientes msg_oob esta opción pide recepción datos fuera-debanda no se recibirían flujo datos algunos protocolos ponen datos despachados prontitud cabeza cola datos nor­males así esta opción </p><h3>#20     17.784560317403844     ../ConsulterRIT/man.es/man2/recvfrom.2</h3><h4>Descripcion:</h4><p>llamadas recvfrom recvmsg se emplean recibir mensajes conector ``socket'' pueden uti­lizarse recibir datos conector sea orientado conexión si no es null conector no es orientado conex­ión dirección fuente del mensaje se argu­ mento londesde es parámetro referencia inicial­izado al tamaño del búfer asociado modificado cuando función regresa indicar tamaño real dirección guardada llamada recv se utiliza normalmente sólo conec­tor conectado vea connect(2)) es idéntica recvfrom parámetro valor tres rutinas devuelven longitud del mensaje cuando terminan si mensaje es demasiado largo como caber búfer suministrado bytes sobran pueden descartarse dependiendo del tipo conector del se reciba mensaje vea si no hay mensajes disponibles conector lla­madas recepción esperan llegue mensaje menos conector sea no bloqueante vea fcntl(2)) cuyo caso se devuelve valor -1 variable externa errno toma valor llamadas recepción devuelven normalmente cualquier dato disponible cantidad pedida vez esperar recepción cantidad pedida completa este comportamiento se ve afectado opciones del nivel conectores so_rcvlowat so_rcv­timeo descritas llamadas select(2) poll(2) pueden emplearse determinar cuándo llegan más argumento flags llamada recv se forma apli­cando operador bits o-lógico más val­ores siguientes msg_oob esta opción pide recepción datos fuera-debanda no se recibirían flujo datos algunos protocolos ponen datos despachados prontitud cabeza cola datos nor­males así esta opción </p><h3>#21     17.784560317403844     ../ConsulterRIT/man.es/man2/recvmsg.2</h3><h4>Descripcion:</h4><p>llamadas recvfrom recvmsg se emplean recibir mensajes conector ``socket'' pueden uti­lizarse recibir datos conector sea orientado conexión si no es null conector no es orientado conex­ión dirección fuente del mensaje se argu­ mento londesde es parámetro referencia inicial­izado al tamaño del búfer asociado modificado cuando función regresa indicar tamaño real dirección guardada llamada recv se utiliza normalmente sólo conec­tor conectado vea connect(2)) es idéntica recvfrom parámetro valor tres rutinas devuelven longitud del mensaje cuando terminan si mensaje es demasiado largo como caber búfer suministrado bytes sobran pueden descartarse dependiendo del tipo conector del se reciba mensaje vea si no hay mensajes disponibles conector lla­madas recepción esperan llegue mensaje menos conector sea no bloqueante vea fcntl(2)) cuyo caso se devuelve valor -1 variable externa errno toma valor llamadas recepción devuelven normalmente cualquier dato disponible cantidad pedida vez esperar recepción cantidad pedida completa este comportamiento se ve afectado opciones del nivel conectores so_rcvlowat so_rcv­timeo descritas llamadas select(2) poll(2) pueden emplearse determinar cuándo llegan más argumento flags llamada recv se forma apli­cando operador bits o-lógico más val­ores siguientes msg_oob esta opción pide recepción datos fuera-debanda no se recibirían flujo datos algunos protocolos ponen datos despachados prontitud cabeza cola datos nor­males así esta opción </p><h3>#22     17.677108342768086     ../ConsulterRIT/man.es/man2/semctl.2</h3><h4>Descripcion:</h4><p>función realiza operación control especificada cmd conjunto semáforos o semáforo sem­num-avo del grupo identificado primer semáforo del conjunto está indicado valor 0 valores válidos cmd son ipc_stat copiar información estructura datos del conjunto semáforos estructura apuntada argumento semnum es proceso realiza llamada debe tener privilegios acceso lectura conjunto ipc_set escribir valores algunos miembros estructura semid_ds apuntada arg.buf estructura datos del conjunto semáforos actualizando tambien su miembro miembros estructura provista usuario struct semid_ds apunta arg.buf son sem_perm.uid sem_perm.gid sem_perm.mode /* solo 9 bits más bajos */ id usuario efectivo del proceso realiza llamada debe ser super-usuario del creador propietario del conjunto argumento sem­num es ipc_rmid borrar inmediatamente conjunto semáforos sus estructuras datos despertando todos procesos espera devuelve error errno puesto id usuario efectivo del proceso realiza llamada debe ser super-usuario del creador propietario del conjunto argumento semnum es getall devuelve semval todos semáforos del conjunto argumento semnum es proceso realiza lla­mada ha tener privilegios lectura conjunto getncnt llamada al sistema devuelve valor semncnt semnum-avo semáforo del con­junto número procesos esperando aumente semval semnum-avo semáforo del proceso realiza lla­mada ha tener privilegios lectura conjunto getpid llamada al sistema devuelve valor sempid semnum-avo semáforo del con­junto pid del proceso ejecutó última llamada semop </p><h3>#23     17.645300465024697     ../ConsulterRIT/man.es/man1/who.1</h3><h4>Descripcion:</h4><p>esta documentación no va ser mantenida partir ahora puede ser inexacta documentación tex­info es ahora fuente esta página manual documenta versión gnu si no se da ningún argumento who imprime siguiente información cada usuario actualmente está conec­tado al sistema nombre cuenta login name terminal tiempo dura ingreso nombre ordenador remoto terminal x si se da argumento no es opción who usa ese vez /etc/utmp como nombre del fichero contiene registro usuarios frecuencia se da /etc/wtmp como argumento who ver aquellos usuarios previamente se conectaron al si se dan dos argumentos no son opciones who imprime solo entrada del usuario está ejecutando deter­minado entrada estándar precedido nombre del tradicionalmente dos argumentos dados son `am i' como `who am i' del t.literalmente `quién soy yo' opciones -m igual `who am -q imprime solo nombres cuenta número usuarios están conectados ignora otras -s ignorado compatibilidad otras versiones -i -u después del tiempo dura ingreso imprime número horas minutos usuario ha estado `.' significa usuario estuvo activo último `old' significa usuario ha estado ocioso durante más 24 -h imprimir línea cabeceras -w -t --message como -s además después del nombre cuenta imprime carácter indicando estado mensajes del usuario + permite mensajes escritura no permite </p><h3>#24     17.555737575010028     ../ConsulterRIT/man.es/man2/fcntl.2</h3><h4>Descripcion:</h4><p>fcntl realiza diversas variadas operaciones operación cuestión se determina mediante cmd f_dupfd hace arg sea copia fd cerrando fd si es mismo resultado se puede obtener fácilmente usando descriptores antiguo nuevo pueden usarse ambos comparten candados locks indicadores posición ficheros banderas flags ejemplo si posición del fichero se modifica usando lseek descriptores posición del otro resulta modi­ficada embargo dos descriptores no comparten bandera close-on-exec bandera close-on-exec copia está desacti­vada singificando se cerrará caso éxito se devuelve nuevo f_getfd lee bandera si bit fd_cloexec es 0 fichero permanecerá abierto durante exec caso contrario se cerrará f_setfd asigna valor bandera close-on-exec al valor especificado bit fd_cloexec f_getfl lee banderas del descriptor todas ban­deras según hayan sido asignadas open(2) serán f_setfl asigna banderas del descriptor al valor asig­nado sólo o_append o_nonblock o_async pueden asignarse otras banderas no se ven banderas se comparten copias hechas dup(2) fork(2) del mismo descriptor banderas su semántica están descritas f_getlk f_setlk f_setlkw se utilizan gestionar candados ficheros discrecionales discretionary file tercer argumento lock es puntero struct flock que puede ser sobrescrita esta f_getlk devuelve estructura flock nos impide obtener candado establece campo l_type del candado f_unlck si no hay f_setlk candado está cerrado cuando l_type es f_rdlck f_wrlck </p><h3>#25     17.519236408006172     ../ConsulterRIT/man.es/man8/vmstat.8</h3><h4>Descripcion:</h4><p>vmstat da información procesos memoria paginación e/s bloque trampas actividad primer informe producido da medias último adicionales dan información período muestreo longitud cualquier caso informes proceso memoria son opciones opción -n hace cabecera se muestre solamente vez lugar intervalo es período actualizaciones si no se especifica ninguno solamente se muestra informe valores medios número es número si no se especi­fica ninguno sí intervalo número se asume como opción -v resulta mostrar información ver­sión descripciones campos procs r número procesos esperando su tiempo b: número procesos espera w: número procesos espacio trasiego embargo este campo se calcula linux nunca hace trasiego memory swpd cantidad memoria virtual empleada free: cantidad memoria inactiva buff: cantidad memoria empleada como búferes swap si cantidad memoria traída del espacio trasiego disco so: cantidad memoria trasegada al disco io bi bloques enviados dispositivo bloques bo: bloques recibidos dispositivo bloques system in número interrupciones segundo incluyendo al cs: número cambios contexto cpu éstos son porcentajes tiempo total us: tiempo usuario sy tiempo sistema id tiempo inactividad observaciones vmstat no requiere permisos estos informes se entienden ayudar identificar cuellos vmstat linux no se cuenta sí mismo como proceso todos bloques linux son al día fecha 1 kb excepto bloques </p><h3>#26     17.241522070990783     ../ConsulterRIT/man.es/man1/mknod.1</h3><h4>Descripcion:</h4><p>mknod crea fifo tubería nombre fichero espe­cial bloques fichero especial caracteres nombre fichero especial es tripleta booleano entero entero almacenado sistema valor lógico escoge fichero especial caracteres fichero especial dos enteros son números dispositivo mayor así fichero especial casi no ocupa sitio disco se emplea sólo comunicación sistema oper­ativo no almacenamiento menudo ficheros especiales se refieren dispositivos físicos disco cinta terminal impresora servicios del sis­tema operativo dev/null ficheros especiales bloque son dispositivos simi­lares discos donde se puede acceder datos dado número bloque tiene sentido tener caché todos otros dispositivos son ficheros espe­ciales (hace tiempo distinción era diferente e/s fichero especial caracteres sería búfer fichero especial bloques orden mknod es crea ficheros este argumento sigue nombre especifica tipo fichero construir p fifo b fichero especial bloques con búfer c fichero especial caracteres sin búferes versión gnu mknod permite `unbuffered' sea sinónimo cuando se construye fichero especial bloques car­acteres hay dar tipo del fichero números dispositivo mayor menor en base diez octal 0 inicial versión gnu también permite hex­adecimal 0x omisión permisos ficheros creados son 0666 `a+rw' menos bits puestos 1 opciones -m modo establece permisos ficheros creados modo es simbólico como chmod(1) emplea modo predeterminado como punto opciones estándares gnu muestra </p><h3>#27     16.890878446613026     ../ConsulterRIT/man.es/man3/catgets.3</h3><h4>Descripcion:</h4><p>catgets() lee mensaje message_number conjunto set_number del catálogo mensajes identificado cat­alog donde catalog es descriptor catálogo devuelto llamada anterior cuarto argu­mento message apunta mensaje predeterminado será devuelto catgets() si catálogo mensajes identificado no está actualmente texto del mensaje está contenido área memoria interna debe ser copiado aplicación si se quiere guardar cadena devuelta siempre se hace terminar byte valor devuelto si tiene éxito catgets() devuelve puntero área memoria interna conteniendo cadena del mensaje termi­nada catgets() devuelve puntero notas estas funciones están disponibles solamente libc.so.4.4.4c the x/open portability guide enero 1987 especifica caso error más sutil se devuelve message si no está disponible catálogo men­sajes especificado catalog mientras se devuelve cada vacía cuando está disponible catálogo men­sajes no contiene mensaje parece ser estos dos casos posibles error se van eliminar xpg4.2 favor siempre se devuelva conforme xpg4.2 véase también catopen(3) setlocale(3) linux 9 agosto 1998 catgets(3) <nl_types h> libc so 4c xpg4 xpg4 </p><h3>#28     16.86380409392326     ../ConsulterRIT/man.es/man2/mlock.2</h3><h4>Descripcion:</h4><p>mlock desactiva paginado memoria grupo direcciones comienza dirección addr longitud len se garantiza todas páginas con­tienen algunas esas direcciones estarán residentes ram cuando llamada al sistema mlock retorne error permanecerán ram dichas páginas sean desblo­quedadas munlock munlockall termine proceso comience otro programa procesos hijos creados mediante fork no heredan bloqueos bloqueo memoria tiene dos aplicaciones fundamen­tales: algoritmos tiempo real procesado datos alta aplicaciones tiempo real requieren temporizado determinista paginado es causas principales retardos inesperados ejecución programas junto gestionado aplicaciones tiempo real suelen conmutar gestor tiempo real software seguridad criptográfico menudo trabaja bytes críti­cos tales como contraseñas claves como resul­tado del paginado estos secretos pueden ser transferidos medio almacenamiento intercambio persistente donde podría ser leído enemigo mucho después programa seguridad haya borrado secretos ram bloqueos memoria no son acumulativos si página ha sido bloqueda varias veces mediante llamadas mlock mlockall será desbloqueada simple llamada munlock rango correspondiente páginas son mapeadas varias zonas varios procesos permanecen bloqueadas ram mientras estén alguna zona sistemas posix mlock munlock disponibles se define _posix_memlock_range <unistd.h> valor pagesize <limits.h> indica número bytes valor devuelto caso éxito mlock devuelve si hay error se devuelve -1 errno se activa convenientemente no se realiza ningún cambio ningún bloqueo espacio direcciones </p><h3>#29     16.781146755960354     ../ConsulterRIT/man.es/man5/ipc.5</h3><h4>Descripcion:</h4><p>esta página del manual hace referencia implementación linux mecanismos comunicación procesos del system v ipc interprocess communication colas mensajes conjuntos semáforos segmentos memoria siguiente descripción palabra recurso se refiere instancia dichos permisos acceso recursos cada recurso sistema utiliza estructura datos común tipo struct ipc_perm almacenar infor­mación necesaria determinar permisos al ejecutar operación estructura ipc_perm definida fichero cabecera <sys/ipc.h> incluye siguientes miembros ushort cuid /* id del usuario creador */ ushort cgid /* id grupo del usuario creador */ ushort uid /* id del usuario dueño */ ushort gid /* id grupo del usuario dueño */ ushort mode /* permisos lectura/escritura */ miembro mode estructura ipc_perm define 9 bits más bajos persmisos acceso al recurso cualquier proceso realice llamada ipc al permisos se interpretan siguiente manera 0400 lectura 0200 escritura 0040 lectura 0020 escritura 0004 lectura 0002 escritura bits 0100 0010 0001 bits ejecución no se además write permiso escritura se inter­preta efectivamente como alter permiso alteración conjunto mismo fichero cabecera del sistema también define siguientes constantes simbólicas ipc_creat crea entrada si clave no ipc_excl falla si clave ipc_nowait devuelve error si petición debe ipc_private clave ipc_rmid elimina ipc_set establece opciones del ipc_stat obtiene opciones del nótese ipc_private es tipo key_t </p><h3>#30     16.72746300137094     ../ConsulterRIT/man.es/man5/lilo.conf.5</h3><h4>Descripcion:</h4><p>este fichero utiliza lilo instalador del cargador arranque véase omisión este fichero es siguiente es ejemplo este fichero boot = /dev/hda delay = 40 compact vga = normal root = /dev/hda1 read-only image = /zimage-2.5.99 label = try image = /zimage-1.0.9 label = 1.0.9 image = /tamu/vmlinuz label = tamu root = /dev/hdb2 vga = ask other = /dev/hda3 label = dos table = /dev/hda este fichero configuración especifica lilo debe usar registro maestro arranque master boot record mba (documentación diversas formas usar lilo su interacción otros sistemas opera­tivos se puede encontrar fichero user.tex documentación cuando sistema arranca cargador arranque espera 4 segundos 40 decisegundos usuario apriete tecla may o ctrl alt si usuario no apri­eta alguna estas teclas primera imagen mencionada del núcleo /zimage-2.5.99 este caso se si usuario aprieta estas teclas cargador arranque pregunta qué imagen caso no recordar posibles opciones púlsese [tab] o [?] teclados norteamericanos lilo presentará menú usuario puede ahora arrancar núcleo nuevo núcleo viejo confiable núcleo otro sistema ficheros raíz en caso haya hecho alguna estupidez sistema ficheros raíz usual arrancar sistema operativo fichero lilo.conf puede tener 16 según muestra ejemplo más arriba fichero con­figuración comienza varias opciones globales las primeras 6 líneas del </p></body></html>