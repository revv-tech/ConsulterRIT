<html><head><title>Consulta: segmentos de memoria compartida</title></head><body><h3>#1     0.0     ../ConsulterRIT/man.es/man4/console.4</h3><h4>Descripcion:</h4><p>sistema linux tiene 63 consolas virtuales dis­positivos carácter número mayor 4 menor 1 63 denominadas habitualmente /dev/ttyn donde 1 <= n <= consola actual se designa también /dev/console /dev/tty0 dispositivo carácter número mayor 4 menor ficheros dispositivo /dev/* se crean normalmente guión makedev mknod(1) habitual­mente modo 0622 propietario/grupo anteriormente versión 1.1.54 del núcleo número consolas virtuales se compilaba propio núcleo en tty.h #define nr_consoles 8 sólo se podía cambiar edi­tando partir versión 1.1.54 consolas virtuales se crean marcha momento se formas habituales arrancar proceso con­sola son a decir init(8) en inittab(5)) arranque getty(8) consola b pedir open(1) arranque proceso consola c arrancar x buscará primera consola libre visualizará allí su (también está viejo doshell(8).) conmutar consola podemos a teclear alt+fn ctrl+alt+fn conmutar consola n altgr+fn puede llevarnos consola n+12 [aquí alt altgr se refieren teclas alt izquierda derecha respectivamente] b usar alt+cursorderecha alt+cursorizquierda hacer ciclo través consolas uso c usar pro­grama (las combinaciones teclas son definibles usuario véase combina­ ciones mencionadas arriba son valores programa deallocvt(1) anteriormente disalloc libera memoria reservada tampones pantalla aque­llas consolas no tengan ningún proceso propiedades consolas conllevan montón espero docu­mentarlo alguna hecho más importante es consolas simulan terminales particular si se imprimen dos caracteres esc </p><h3>#2     0.0     ../ConsulterRIT/man.es/man4/console_codes.4</h3><h4>Descripcion:</h4><p>consola linux implementa vasto subconjunto controles terminal vt102 del estándar ecma-48/iso 6429/ansi x3.64 más ciertas secuencias modo privadas cambiar paleta colores asocia­ciones conjuntos caracteres descrip­ ciones tabulares abajo 2ª columna da mnemónicos ecma-48 dec éstos prefijados dec función secuencias mnemónico no son ecma-48 después haber hecho todo procesamiento salida normal flujo caracteres llega al contro­lador consola impresión verdad 1ª cosa ocurre es traducción del código empleado procesamiento al código empleado si consola está modo utf-8 entonces bytes llegan se ensamblan 1º códigos 16 b si no cada byte se transforma según tabla asocia­ciones curso que traduce valor vea más abajo sección conjuntos caracteres dis­cusión caso normal valor unicode se convierte índice tipo letra éste se almacena memoria vídeo forma aparezca pantalla grafo cor­respondiente según se encuentra rom observe empleo unicode y diseño del hardware del pc nos permite usar 512 grafos diferentes si valor actual unicode es carácter control estamos actualmente procesando secuencia escape valor se tratará vez convertirse índice tipo presentarse como grafismo puede lan­zar movimiento del cursor otra función vea sección controles consola linux abajo discusión generalmente no es buena idea codificar directamente controles terminal linux tiene base datos terminfo(5) capacidades vez emitir mano secuencias escape consola debería </p><h3>#3     0.0     ../ConsulterRIT/man.es/man4/console_ioctl.4</h3><h4>Descripcion:</h4><p>atención si usa siguiente información es su allá atención: estas llamadas ioctl son internas linux no documentadas sujetas cambios previo use fun­ciones se admiten siguientes peticiones ioctl() peculiares cada requiere tercer argumento supuesto aquí como kdgetled obtiene estado argp apunta long 3 bits más bajos *argp se ponen según estado leds como sigue led_cap 0x04 led mayús lec_num 0x02 led num led_scr 0x01 led despl kdsetled enciende leds se encienden según 3 bits más bajos embargo si se pone bit más alto orden leds se ponen su funcionamiento normal mostrar estado funciones del teclado bloqueo mayúsculas teclado auxiliar numérico antes 1.1.54 leds simplemente reflejaban estado correspondientes señales del teclado kdgetled/kdsetled tamibén cambiaban señales del 1.1.54 leds pueden mostrar información arbitraria omisión muestran señales del 2 siguientes llamadas ioctl se usan acceder señales del kdgkbled obtiene señales del teclado bloq.mayús blo­qnum bloqdespl no argp apunta char se pone estado 3 bits más orden máscara 0x7 obtienen estado señal actual bits más orden siguiente cuarteta máscara 0x70 obtienen estado señal (desde kdskbled pone señales del teclado bloq.mayús bloqnum bloqdespl no argp tiene estado señal 3 bits más orden máscara 0x7 tienen estado señal bits más orden siguiente cuarteta máscara 0x70 tienen estado </p><h3>#4     0.0     ../ConsulterRIT/man.es/man4/console_ioctls.4</h3><h4>Descripcion:</h4><p>warning if you use the following information you are going to burn warning: ioctl's are undocumented linux internals liable to be changed without use posix functions where the following linux-peculiar ioctl() requests are each requires third argument assumed here to be kdgetled get state of argp points to long the lower three bits of *argp are set to the state of the leds as follows led_cap 0x04 caps lock led lec_num 0x02 num lock led led_scr 0x01 scroll lock led kdsetled set the the leds are set to correspond to the lower three bits of however if higher order bit is set the leds revert to normal dis­playing the state of the keyboard functions of caps lock num lock and scroll before 1.1.54 the leds just reflected the state of the corresponding keyboard flags and kdgetled/kdsetled would also change the keyboard since 1.1.54 the leds can be made to display arbitrary information but by default they display the keyboard the following two ioctl's are used to access the keyboard kdgkbled get keyboard flags capslock numlock scrolllock not argp points to char which is set to the flag the low order three bits mask 0x7 get the current flag state and </p></body></html>